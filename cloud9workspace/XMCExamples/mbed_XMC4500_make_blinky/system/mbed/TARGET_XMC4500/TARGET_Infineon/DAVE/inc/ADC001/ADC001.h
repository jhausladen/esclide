/*******************************************************************************
**  DAVE App Name : ADC001       App Version: 1.0.22               
**  This file is generated by DAVE, User modification to this file will be    **
**  overwritten at the next code generation.                                  **
*******************************************************************************/

/******************************************************************************
 *
 * Copyright (C) 2013 Infineon Technologies AG. All rights reserved.
 *
 * Infineon Technologies AG (Infineon) is supplying this software for use with
 * Infineon's microcontrollers.
 * This file can be freely distributed within development tools that are
 * supporting such microcontrollers.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL,
 * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : DAVE App Developer                                              **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : Sep 27, 2013                                           **
**                                                                            **
*******************************************************************************/
/*******************************************************************************
**                       Author(s) Identity                                   **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** CM           DAVE App Developer                                            **
** ---------------------------------------------------------------------------**
**                                                                            **
*******************************************************************************/

/**
 * @file ADC001.h
 *
 * @brief This header file contains the data structures and function prototypes 
 *        of ADC001 App
 *
 * Change History:
 *
 * Date         version       Details
 * 16-Dec-2012   1.0.4    Initial code added for XMC1000
 * 06-Mar-2013   1.0.6    App version changed for XMC1000 and XMC4400/XMC4200
 * 24-Apr-2013   1.0.8    Ported to XMC4500 step AB and
 *                        Source Result selection Feature added
 * 11-Jun-2013   1.0.10   1. In channel selection page Group C and Group D check 
 *                        boxes made invisible for XMC1200/1300/4200 devices.
 *                        2. In the Header comment section device name changed
 *                           to XMC1000.
 *                        3. Tooltip for the Group channel selection is modified.
 *                        4. New api ADC001_GetFastResult() implemented.
 *                        5. Source Result register selection feature disabled
 *                           due to header file update not available.     
 * 27-Jun-2013   1.0.12   Source Result register selection feature removed to
 *                        simplify the app.
 * 27-Sep-2013   1.0.16   Typos in API Documentation & .h comments is corrected.
 */
#ifndef ADC001_H_
#define ADC001_H_

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************
 * INCLUDE FILES
 *****************************************************************************/
#include <DAVE3.h>


/******************************************************************************
**                      Global Macro Definitions                              **
*******************************************************************************/
/** Maximum service request nodes */
#define ADC001_MAX_SERVICE_REQUEST_NODE  4

/** Maximum ADC group */
#define ADC001_MAX_ADC_GROUP   4

/** Maximum ADC channels per group */
#define ADC001_MAX_ADC_GROUP_CHANNEL  8

/** Total number of ADC channels */
#define ADC001_TOTAL_ADC_CHANNEL    32

/** Maximum group specific boundary */
#define ADC001_MAX_BOUNDARY_VALUE  4096

/** Maximum sample time control register value */
#define ADC001_MAX_SAMPLE_TIME_CONTROL_VAL  32
/*******************************************************************************
**                      Global Type Definitions                               **
*******************************************************************************/

/**
 * @ingroup ADC001_publicparam
 * @{
 */
/*******************************************************************************
 *                                ENUMERATIONS                                **
 ******************************************************************************/
/**
 * This enumerates the state of the App.
 */
typedef enum ADC001_StateType
{
  /**
   * This is the Default state of an APP after power on reset.
   */
  ADC001_UNINITIALIZED,
  /**
   * This is the INITIALIZED state in which APP is initialized as per selected
   * parameters.
   */
  ADC001_INITIALIZED
}ADC001_StateType;


/**
 * This will enumerate the error codes which will be returned from a function.
 */
typedef enum ADC001_ErrorCodesType
{
  /**
   * This code would be returned when any operation is not possible cause that
   * operation was tried in invalid state
   */
    /*
    GROUPID  #41
    MODULENAME = ADC001
    */
    /*
    ERRCODESTRING = ADC001_OPER_NOT_ALLOWED_ERROR
    STRCODESTRING = Function execution is not allowed in the current state
    */  
  ADC001_OPER_NOT_ALLOWED_ERROR = 1,
  /**
   * This code is returned when parameter passed to API are invalid
   */
  /*
  ERRCODESTRING = ADC001_INVALID_PARAM_ERROR
  STRCODESTRING = Input parameter is not valid
  */ 
  ADC001_INVALID_PARAM_ERROR,
  /*
  ERRCODESTRING = ADCCH001_INVALID_RESULT
  STRCODESTRING = Conversion result is invalid
  */  
  ADC001_INVALID_RESULT,  
  /** Debug log messages */
  /**
   * Message Id for function Entry
   */
  /*
  ERRCODESTRING = ADC001_FUN_ENTRY
  STRCODESTRING = Function entered
  */ 
  ADC001_FUNCTION_ENTRY,
  /**
   * Message ID for function exit
   */
  /*
  ERRCODESTRING = ADC001_FUN_EXIT
  STRCODESTRING = Function exited
  */ 
  ADC001_FUNCTION_EXIT,
}ADC001_ErrorCodesType;


/**
 * This enumerates the enable or disable of associated arbitration slot.
 */
typedef enum ADC001_ArbitrationSlot
{
  /**
   * Disable the arbitration slot
   */
  ADC001_ARBITRATION_SLOT_DISABLE = 0,
  /**
   * Enable the arbitration slot
   */
  ADC001_ARBITRATION_SLOT_ENABLE
}ADC001_ArbitrationSlot;


/**
 * This enumerates the start conversion after initialization.
 */
typedef enum ADC001_ConversionAfterInit
{
  /**
   * Disable start conversion after initialization
   */
  ADC001_START_CONV_DISABLE = 0,
  /**
   * Enable conversion after initialization
   */
  ADC001_START_CONV_ENABLE
}ADC001_ConversionAfterInit;


/**
 * This enumerates the auto scan functionality 
 */
typedef enum ADC001_Autoscan
{
  /**
   * Auto scan functionality disabled
   */
  ADC001_AUTOSCAN_DISABLE = 0,
  /**
   * Auto scan functionality enabled
   */
  ADC001_AUTOSCAN_ENABLE
}ADC001_Autoscan;

/**
 * This enumerates the result position alignment.
 */
typedef enum ADC001_PosAlign
{
  /**
   * Result is Left aligned.
   */
  ADC001_LEFT_ALIGN = 0,
  /**
   * Result is Right aligned.
   */
  ADC001_RIGHT_ALIGN
}ADC001_PosAlign;


/**
 * This enumerates the global input class
 */
typedef enum ADC001_GlobalInPutClass
{
  /**
   * Global input class 0
   */
  ADC001_GLOBAL_CLASS0 = 2,
  /**
   * Global input class 1
   */
  ADC001_GLOBAL_CLASS1 
}ADC001_GlobalInPutClass;


/**
 * This enumerates the gating mode.
 */
typedef enum ADC001_GatingMode
{
  /**
   * Gating is disabled.
   */
  ADC001_GATING_DISABLED=0,
  /**
   * Gating is enabled always.
   */
  ADC001_GATING_ENABLED_ALWAYS=1,
  /**
   * Gating is enabled for high level.
   */
  ADC001_GATING_ENABLED_FOR_HIGH=2,
  /**
   * Gating is enabled for low level.
   */
  ADC001_GATING_ENABLED_FOR_LOW=3,
}ADC001_GatingMode;


/**
 * This enumerates the external trigger mode.
 */
typedef enum ADC001_TriggerMode
{
  /**
   * External trigger disabled
   */
  ADC001_NOTRIGGER=0,
  /**
   * External trigger on falling edge
   */
  ADC001_TRIGGER_UPON_FALLING_EDGE=1,
  /**
   * External trigger on rising edge
   */
  ADC001_TRIGGER_UPON_RISING_EDGE=2,
  /**
   * External trigger on both edges
   */
  ADC001_TRIGGER_UPON_BOTH_EDGE=3,
}ADC001_TriggerMode;

/**
 * This enumerates the priority.
 */
typedef enum ADC001_Priority
{
  /**
   * App priority 0
   */
  ADC001_PRIORITY0=0,
  /**
   * App priority 1
   */
  ADC001_PRIORITY1=1,
  /**
   * App priority2
   */
  ADC001_PRIORITY2=2,
  /**
   * App priority 3
   */
  ADC001_PRIORITY3=3,
}ADC001_Priority;


/**
 * This enumerates the autoscan source load event mode
 */
typedef enum ADC001_LoadEventMode
{
  /**
   * Copy all bits from the select registers to the
   * pending registers upon a load event.
   */
  ADC001_OVERWRITE_MODE = 0,
  /**
   * Set all pending bits that are set in the select
   * registers upon a load event (logic OR)
   */
  ADC001_COMBINE_MODE
}ADC001_LoadEventMode;


/**
 * This enumerates the channel event mode
 */
typedef enum ADC001_ChannelEventMode
{
  /**
   * Channel event disabled
   */
  ADC001_CHANNEL_EVENT_NEVER = 0,
  /**
   * Channel event occurs if result is inside boundary
   */
  ADC001_CHANNEL_EVENT_INSIDE_BOUNDARY,
  /**
   * Channel event occurs if result is outside boundary
   */
  ADC001_CHANNEL_EVENT_OUTSIDE_BOUNDARY,
  /**
   * Channel event enabled
   */
  ADC001_CHANNEL_EVENT_ALWAYS,
}ADC001_ChannelEventMode;

/**
 * This enumerates the start mode
 */
typedef enum ADC001_StartMode
{
  /**
   * Wait for start mode
   * The requested channel is sampled after the current conversion 
   * has finished
   */
  ADC001_WAIT_FOR_START = 0,
  /**
   * Cancel inject Repeat mode
   * After an injected conversion has finished,the interrupted conversion 
   * request is injected into the pipeline,hence the measurement is repeated.
   */
  ADC001_CANCEL_INJECT_REPEAT=1,
  /**
   * Cancel inject Repeat mode with cancel mode
   * In case of an ongoing conversion, this conversion is cancelled, the requested
   * channel is sampled and converted immediately.
   */
   ADC001_CANCEL_INJECT_REPEAT_WITH_CANCEL=2,
}ADC001_StartMode;


/**
 * This enumerates the result read mode
 */
typedef enum ADC001_ResultReadMode
{

  /**
   * Result overwrite mode
   * Result will be overwritten whether previous result is read or not 
   */
  ADC001_RESULT_OVERWRITE_MODE = 0,

  /**
   * Wait for read mode
   * Result will be updated only if previous result is read
   */
  ADC001_WAIT_FOR_READ = 1
}ADC001_ResultReadMode;


/**
 * This structure holds the parameters which change at run time.
 */
typedef struct ADC001_DynamicDataType
{
  /**
   * This is group number of the channel corresponding to the value in global result register.
   */
  uint8_t GroupNo;
  /**
   * This is channel number corresponding to the value in global result register.
   */
  uint8_t ChannelNo;
  /** This is the result of the conversion */
  uint16_t Result;
  /**
   * This enumerates the state of the App.
   */
  ADC001_StateType State;
}ADC001_DynamicDataType;

/**
 * This structure holds all the static configuration parameters of the Event
 * Counter APP.
 */
typedef struct ADC001_HandleType
{
  /**
   * This is ADC group number.
   */
  const uint8_t kGroupNo;
  /**
   * This is total number of ADC channels selected.
   */
  const uint8_t kChannels;  
  /**
   * This contains combined value of channels selected for Scan sequence
   * from group 0 
   */  
  const uint8_t kGroup0ChSelect;
  /**
   * This contains combined value of channels selected for Scan sequence
   * from group 1 
   */  
  const uint8_t kGroup1ChSelect;  
  /**
   * This contains combined value of channels selected for Scan sequence
   * from group 2 
   */  
  const uint8_t kGroup2ChSelect;
  /**
   * This contains combined value of channels selected for Scan sequence
   * from group 3 
   */  
  const uint8_t kGroup3ChSelect;
  /**
   * This is number of ADC channels selected from Group A.
   */
  const uint8_t kGrpAChannels;
  /**
   * This is number of ADC channels selected from Group B.
   */
  const uint8_t kGrpBChannels;
  /**
   * This is number of ADC channels selected from Group C.
   */
  const uint8_t kGrpCChannels;
  /**
   * This is number of ADC channels selected from Group D.
   */
  const uint8_t kGrpDChannels; 
  /*
   * This indicates Active channels.
   */
  uint8_t kActiveChannels[4][8];
  
  /*
   * This indicates Active groups.
   */
  uint8_t kActiveGroups[4];  
  /**
   * This is to enable or disable arbitration slot.
   */
  const uint8_t kAsenEnable;
  /**
   * This is to select conversion start mode.
   */
  const uint8_t kStart;
  /**
   * This is priority of request source.
   */
  const uint8_t kPriority;
  /**
   * This is to select external trigger mode.
   */
  const uint8_t kTriggerMode;
  /**
   * This is to enable or disable external trigger mode.
   */  
  const uint8_t kTriggerEn;
  /**
   * This is to select gating mode.
   */
  const uint8_t kGatingMode;
  /**
   * This is to select result read mode.
   */  
  const uint8_t kResultReadMode;
  /**
   * This is to select conversion start mode.
   */  
  const uint8_t kStartmode;  
  /**
   * This is to enable or disable auto scan mode. 
   */
  const uint8_t kAutoScan;
  /**
   * This is to control the result alignment. 
   */
  const uint8_t kResultControl;
  /**
   * This is to enable or disable result event. 
   */  
  const uint8_t kResultEvtEnable;
  /**
   * This is to enable or disable resource event. 
   */  
  const uint8_t kResourceEvtEnable;
  /**
   * This is to select input class. 
   */  
  const uint8_t kIpClassSel;
  /**
   * This is the pointer to the structure which holds the parameters which 
   * change at run time.
   */
  ADC001_DynamicDataType * DynamicHandlePtr;
  /**
   * This is the pointer to the VADC Global Registers.
   */
  VADC_GLOBAL_TypeDef* VADCGlobalPtr;
  /**
   * This is the pointer to the VADC group 0 Registers.
   */
  VADC_G_TypeDef* VADCGroup0Ptr;
  /**
   * This is the pointer to the VADC group 1 Registers.
   */  
  VADC_G_TypeDef* VADCGroup1Ptr;
  /**
   * This is the pointer to the VADC group 2 Registers.
   */  
  VADC_G_TypeDef* VADCGroup2Ptr;
  /**
   * This is the pointer to the VADC group 3 Registers.
   */  
  VADC_G_TypeDef* VADCGroup3Ptr;  
}ADC001_HandleType;


/**
 * This is the channel handle.
 */  
typedef struct ADC001_ChannelHandleType
{
  /**
   * This is group number of assigned channel.
   */
  const uint8_t kGroupNo;
  /**
   * This is channel number of assigned channel.
   */  
  const uint8_t kChannelNo;
  /**
   * This is to enable or disable the channel for scan sequence.
   */  
  const uint8_t kEnable;
}ADC001_ChannelHandleType;


/**
 * This is the result handle.
 */
typedef struct ADC001_ResultHandleType
{
  /**
   * This is group number of the channel corresponding to the value in global result register.
   */
  uint8_t GroupNo;
  /**
   * This is channel number corresponding to the value in global result register.
   */
  uint8_t ChannelNo;
  /**
   * This is the value of conversion result.
   */
  uint16_t Result;
}ADC001_ResultHandleType;

/**
 * @}
 */
/**
 * @ingroup ADC001_apidoc
 * @{
 */
 
/*******************************************************************************
** FUNCTION PROTOTYPES                                                        **
*******************************************************************************/

/**
 * @brief This function initializes the ADC background App with the configured
 * parameters.
 * @return None <BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 * int main(void)
 * {
 *    DAVE_Init(); //ADC001_Init is called within DAVE_Init
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
void ADC001_Init(void);

/**
 * @brief This function resets the App.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 * DAVEApp_SUCCESS: if the function is successful.<BR><BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *    //Call the deinit function to reset the app to default values.
 *    Status = 
 *          ADC001_Deinit((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_Deinit(const ADC001_HandleType* HandlePtr);

/**
 * @brief This function selects the global input class for the channel.
 * @param[in] HandlePtr pointer to the Instance variable
 * @param[in] Class Global input class number
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in 
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the selected class number is other than     
 *                                   global class<BR>
 * 
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set group specific boundary 0.
 *    Status =
 *          ADC001_SelectInputClass(
 *            (ADC001_HandleType*)&ADC001_Handle0, ADC001_GLOBAL_CLASS0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 *
 */
status_t ADC001_SelectInputClass(const ADC001_HandleType* HandlePtr, 
                                                 ADC001_GlobalInPutClass Class);
/**
 * @brief This function enables the result event. This is enabled for global result register and
 * as global result register is shared by all the channels it is applicable for all the conversions.
 * @param[in] HandlePtr pointer to the Instance variable
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b> <BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint16_t Result;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    // Enable Result event service request
 *    Status =
 *          ADC001_EnableResultEvt((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_EnableResultEvt(const ADC001_HandleType* HandlePtr);
                                                          
/**
 * @brief This function disables the result event.
 * @param[in] HandlePtr pointer to the Instance variable
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b> <BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint16_t Result;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Disable Result event service request
 *    Status =
 *          ADC001_DisableResultEvt((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_DisableResultEvt(const ADC001_HandleType* HandlePtr);

/**
 * @brief This function returns the result of the normal mode ADC conversion.
 *        Result read mode is configured as "wait-for-read". <b>Use this API to read result
 *        of each conversion so that next background scan conversion result can be written into the global result register.</b>
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ResultPtr Pointer to store conversion result.<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the ResultPtr is NULL.<BR>
 * ADC001_INVALID_RESULT : If the result is not updated. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    ADC001_ResultHandleType Result;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Get the result
 *    Status =
 *          ADC001_GetResult(
 *            (ADC001_HandleType*)&ADC001_Handle0, &Result);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_GetResult(const ADC001_HandleType* HandlePtr, 
                                            ADC001_ResultHandleType* ResultPtr);
/**
 * @brief This function returns the result of the normal mode ADC conversion without checking the valid bitfield.
 *        Result read mode is configured as "wait-for-read". <b>Use this API to read result
 *        of each conversion so that next background scan conversion result can be written into the global result register.</b>
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>uint16_t</b><BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    uint32_t AdcResult;
  *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Get the result
 *    AdcResult =  ADC001_GetFastResult((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */ 
uint16_t ADC001_GetFastResult(const ADC001_HandleType* HandlePtr);
                      
/**
 * @brief This function checks whether Result event flag is set.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] EvtStatus Pointer to store the status of result event flag.<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if EvtStatus is NULL.<BR><BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t ResultEvt;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Get result event flag
 *    Status =
 *          ADC001_GetResultEvtFlag(
 *            (ADC001_HandleType*)&ADC001_Handle0, &ResultEvt);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_GetResultEvtFlag(const ADC001_HandleType* HandlePtr, 
                                                            uint8_t* EvtStatus);

/**
 * @brief This function sets the result event flag through software.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set result event flag
 *    Status =
 *          ADC001_SetResultEvtFlag((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetResultEvtFlag(const ADC001_HandleType* HandlePtr);


/**
 * @brief This function clears the pending result event flag.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Clear result event flag
 *    Status =
 *          ADC001_ClearResultEvtFlag((ADC001_HandleType*)&ADC001_Handle0, 1);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_ClearResultEvtFlag(const ADC001_HandleType* HandlePtr);
/**
 * @brief This function checks whether Channel event flag is set.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] EvtStatus Pointer to hold the status of channel event flag.
 * @param[in] ChannelPtr Pointer to the Channel handle
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if EvtStatus or ChannelPtr is NULL.
 *                                   if the group number or channel number in
 *                                   channel handle is invalid or not consumed<BR><BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t ChEvtStat;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Get channel event flag status
 *    Status =
 *          ADC001_GetChannelEvtFlag(
 *            (ADC001_HandleType*)&ADC001_Handle0, &ChEvtStat, &ADC001_ChannelAAHandle);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_GetChannelEvtFlag(const ADC001_HandleType* HandlePtr, 
                                  uint8_t* EvtStatus,
                                  const ADC001_ChannelHandleType* ChannelPtr);

/**
 * @brief This function sets the channel event flags through software.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the Channel handle
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the ChannelPtr is NULL.
 *                                   if the group number or channel number in
 *                                   channel handle is invalid or not consumed<BR><BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set Channel event flag.
 *    Status =
 *          ADC001_SetChannelEvtFlag(
 *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetChannelEvtFlag(const ADC001_HandleType* HandlePtr,
                                  const ADC001_ChannelHandleType* ChannelPtr);

/**
 * @brief This function clears the pending channel event flag.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the Channel handle<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in   
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the ChannelPtr is NULL.   
 *                                   if the group number or channel number in
 *                                   channel handle is invalid or not consumed<BR><BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t StartSelect;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Clear channel event flag
 *    Status =
 *          ADC001_ClearChannelEvtFlag(
 *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_ClearChannelEvtFlag(const ADC001_HandleType* HandlePtr,
                                    const ADC001_ChannelHandleType* ChannelPtr);

/**
 * @brief This function enables the background request
 *        source event. This event is generated after all the conversions in the
 *        background scan sequence are finished.
 * @param[in] HandlePtr pointer to the Instance variable
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * <b>Reentrant: yes</b> <BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t EvtflgStat;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    // Enable background request source event service request.
 *    Status =
 *          ADC001_EnableBackGroundEvent((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_EnableBackGroundEvent(const ADC001_HandleType* HandlePtr);

/**
 * @brief This function disables the background request
 *        source event.
 * @param[in] HandlePtr pointer to the Instance variable
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * <b>Reentrant: yes</b> <BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t EvtflgStat;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Disable background request source event service request.
 *    Status =
 *          ADC001_DisableBackGroundEvent((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_DisableBackGroundEvent(const ADC001_HandleType* HandlePtr);

/**
 * @brief This function checks whether background source event flag is set.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] EvtStatus Pointer to store the status of background even flag<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the EvtStatus is NULL.   <BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t EvtflgStat;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set EMUX channel select value.
 *    Status =
 *          ADC001_GetBackGroundEvtFlag(
 *            (ADC001_HandleType*)&ADC001_Handle0, &EvtflgStat);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_GetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr, 
                                                           uint8_t* EvtStatus);

/**
 * @brief This function sets the background source event flag through software.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 * 
 * DAVEApp_SUCCESS: if the function is successful<BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 * ADC001_UNINITIALIZED State.<BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set EMUX Mode.
 *    Status =
 *          ADC001_SetBackGroundEvtFlag((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr);

/**
 * @brief This function clears the background resource event flag.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful. <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Clears background request source event. 
 *    Status =
 *         ADC001_ClearBackGroundEvtFlag((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_ClearBackGroundEvtFlag(const ADC001_HandleType* HandlePtr);

/**
 * @brief This function clears pending bits.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Clear pending bits.
 *    Status =
 *          ADC001_ClearPendingBits((ADC001_HandleType*)&ADC001_Handle0;
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_ClearPendingBits(const ADC001_HandleType *HandlePtr);

/**
 * @brief This function generates a load event for the background scan sequence.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Generate load event
 *    Status =
 *          ADC001_GenerateLoadEvent((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_GenerateLoadEvent(const ADC001_HandleType *HandlePtr);

/**
 * @brief This function enables the gating feature.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] GateSelectVal Gate selection value<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 * ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the GateSelectVal value is above 
 *                                   ADC001_GATING_ENABLED_FOR_LOW<BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Enable gating
 *    Status =
 *          ADC001_EnableGate((ADC001_HandleType*)&ADC001_Handle0,
 *                            ADC001_GATING_ENABLED_FOR_LOW);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
 
 
status_t ADC001_EnableGate(const ADC001_HandleType *HandlePtr, 
                                              uint8_t GateSelectVal);
                                              
                                              
/**
 * @brief This function gives the selected gate signal input level.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] GeteLvlPtr Selected Gate level value<BR>
 * @return <b>status_t</b><BR>
 * 
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 * ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: if the GeteLvlPtr value is NULL.<BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    uint8_t GateLevel;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Get selected gate input level.
 *    Status =
 *          ADC001_GetGateLevel((ADC001_HandleType*)&ADC001_Handle0,
 *                                                                &GateLevel);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_GetGateLevel(const ADC001_HandleType* HandlePtr, 
                                                          uint8_t* GeteLvlPtr);


/**
 * @brief This function sets the external trigger mode. It enables the external trigger
 * when mode is non-zero.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] TriggerMode Value of external trigger mode<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If TriggerMode > 3 <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set external trigger mode.
 *    Status =
 *          ADC001_SetExternalTriggerMode((ADC001_HandleType*)&ADC001_Handle0,
 *                                               ADC001_TRIGGER_UPON_BOTH_EDGE);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetExternalTriggerMode(const ADC001_HandleType *HandlePtr, 
                                                         uint8_t TriggerMode);


/**
 * @brief This function enables external trigger.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * 
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Enable external trigger.
 *    Status =
 *          ADC001_EnableExternalTrigger((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_EnableExternalTrigger(const ADC001_HandleType *HandlePtr);

/**
 * @brief This function disables external trigger.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Disables the external trigger.
 *    Status =
 *          ADC001_DisableExternalTrigger((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_DisableExternalTrigger(const ADC001_HandleType *HandlePtr);

/**
 * @brief This function enables background scan arbitration slot.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Enable arbitration slot for background request source.
 *    Status =
 *          ADC001_EnableArbitrationSlot((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_EnableArbitrationSlot(const ADC001_HandleType *HandlePtr);

/**
 * @brief This function disables background scan arbitration slot.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Disable arbitration slot for background request source. 
 *    Status =
 *          ADC001_DisableArbitrationSlot((ADC001_HandleType*)&ADC001_Handle0);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_DisableArbitrationSlot(const ADC001_HandleType *HandlePtr);

/**
 * @brief This function sets the Autoscan Source Load Event Mode.<BR>
 *        Overwrite Mode or Combine Mode can be selected.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] EventMode Value of event mode<BR> 
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If the EventMode value is apart from 
 *                             ADC001_OVERWRITE_MODE or ADC001_COMBINE_MODE. <BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set conversion mode for standard conversion in group input class 0.
 *    Status =
 *          ADC001_SetLoadEventMode(
 *            (ADC001_HandleType*)&ADC001_Handle0, ADC001_COMBINE_MODE);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetLoadEventMode(const ADC001_HandleType *HandlePtr, 
                                                             uint8_t EventMode);


/**
 * @brief This function sets the required channel in channel pending register.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the channel handle<BR> 
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL.
 *                             if the group number or channel number in
 *                             channel handle is invalid or not consumed<BR><BR> 
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set pending bit for channels to include in the conversion
 *    Status =
 *          ADC001_SetPendingChannel(
 *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetPendingChannel(const ADC001_HandleType *HandlePtr,
                                  const ADC001_ChannelHandleType* ChannelPtr);

/**
 * @brief This function clears the required channel in channel pending register.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the Channel handle<BR> 
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL.
 *                             if the group number or channel number in
 *                             channel handle is invalid or not consumed<BR><BR> 
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Clear pending bit for channels to exclude from the conversion.
 *    Status =
 *          ADC001_ClearPendingChannel(
 *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_ClearPendingChannel(const ADC001_HandleType *HandlePtr,
                                    const ADC001_ChannelHandleType* ChannelPtr);
                                          
/**
 * @brief This function selects the channel for conversion. It adds one channel at 
 * a time in the background scan sequence.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the channel handle<BR> 
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL.
 *                             if the group number or channel number in
 *                             channel handle is invalid or not consumed<BR><BR>  
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Select channel for conversion.
 *    Status =
 *          ADC001_SetChannelSelect((ADC001_HandleType*)&ADC001_Handle0, 
 *                                   &ADC001_ChannelAAHandle);
 *    Status =
 *          ADC001_SetChannelSelect((ADC001_HandleType*)&ADC001_Handle0, 
 *                                   &ADC001_ChannelBDHandle);
 *    Status =
 *          ADC001_SetChannelSelect((ADC001_HandleType*)&ADC001_Handle0, 
 *                                   &ADC001_ChannelBAHandle);
 *                                   
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetChannelSelect(const ADC001_HandleType *HandlePtr,
                                 const ADC001_ChannelHandleType* ChannelPtr);
                                          
/**
 * @brief This function clears the required channel from channel pending register.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the channel handle<BR> 
 * @return <b>status_t</b><BR>
 *
 * DAVEApp_SUCCESS: if the function is successful <BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL.
 *                             if the group number or channel number in
 *                             channel handle is invalid or not consumed<BR><BR>
 *
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Clear channel from scan sequence.
 *    Status =
 *          ADC001_ClearChannelSelect((ADC001_HandleType*)&ADC001_Handle0, 
 *                                    &ADC001_ChannelAAHandle);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_ClearChannelSelect(const ADC001_HandleType *HandlePtr,
                                   const ADC001_ChannelHandleType* ChannelPtr);
                                          
/**
 * @brief This function sets the channel event mode.
 * @param[in] HandlePtr pointer to the Instance variable<BR>
 * @param[in] ChannelPtr Pointer to the channel handle<BR>
 * @param[in] EventMode Channel event mode
 * @return <b>status_t</b><BR>
 * 
 * DAVEApp_SUCCESS: if the function is successful<BR>
 * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in
 *                          ADC001_UNINITIALIZED State. <BR>
 * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL.
 *                             EventMode value is apart from ADC001_CHANNEL_EVENT_NEVER
 *                             or ADC001_CHANNEL_EVENT_ALWAYS. <BR>
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 * @code
 * #include <DAVE3.h>
 *
 * int main(void)
 * {
 *    status_t Status;
 *    DAVE_Init();//ADC001_Init is called within DAVE_Init
 *
 *    //Set channel event mode
 *    Status = 
 *    ADC001_SetChannelEventMode((ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle, 
 *                                              ADC001_CHANNEL_EVENT_ALWAYS);
 *    while(1);
 *    return 0;
 * }
 * @endcode
 */
status_t ADC001_SetChannelEventMode(const ADC001_HandleType *HandlePtr,
                                    const ADC001_ChannelHandleType* ChannelPtr,
                                    uint8_t EventMode);

#include "ADC001_Conf.h"
/**
 * @}
 */

#ifdef __cplusplus
}
#endif
  
#endif /* ADC001_H_ */

